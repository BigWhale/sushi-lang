# Comprehensive test for move semantics vs copy semantics across different types
# Move semantics should ONLY apply to dynamic arrays
# All other types (primitives, strings, fixed arrays, structs) should be copied

fn main() i32:
    # Test 1: Primitive types should be COPIED, not moved
    let i32 x = 42
    let i32 y = 10
    y := x  # Copy, not move
    # x should still be usable
    println(x)  # Should print 42
    println(y)  # Should print 42

    # Test 2: Strings should be COPIED, not moved
    let string s1 = "hello"
    let string s2 = "world"
    s2 := s1  # Copy, not move
    # s1 should still be usable
    println(s1)  # Should print "hello"
    println(s2)  # Should print "hello"

    # Test 3: Dynamic arrays SHOULD be moved
    let i32[] arr1 = from([1, 2, 3])
    let i32[] arr2 = new()
    arr2 := arr1  # Move - arr1 becomes invalid
    # arr1 is now moved, cannot use it
    println(arr2.len())  # Should print 3

    # Test 4: Multiple rebinds of primitives
    let i32 a = 1
    let i32 b = 2
    let i32 c = 3
    b := a  # Copy
    c := b  # Copy
    # All should still be usable
    println(a)  # Should print 1
    println(b)  # Should print 1
    println(c)  # Should print 1

    # Test 5: Rebinding in loops (the original bug)
    let i32 i = 0
    let i32 counter = -1
    while (i < 5):
        if (i == 3):
            counter := i  # Copy, not move
        i := i + 1  # This should work - i is not moved
    println(i)       # Should print 5
    println(counter) # Should print 3

    return Result.Ok(0)
