# Test direct initialization of dynamic arrays from function calls
# This test verifies that the limitation "Cannot directly initialize dynamic arrays
# with function call results" has been removed.
use <collections/strings>

fn create_numbers() i32[]:
    let i32[] arr = from([10, 20, 30])
    return Result.Ok(arr)

fn create_empty() string[]:
    let string[] arr = new()
    return Result.Ok(arr)

fn create_sequence(i32 count) u8[]:
    let u8[] seq = new()
    let i32 i = 0
    while (i < count):
        seq.push((i % 256) as u8)
        i := i + 1
    return Result.Ok(seq)

fn run_test() i32:
    # Test 1: Direct initialization from function call returning Result<i32[]>
    # This now works without the two-step workaround!
    let i32[] numbers = create_numbers()??
    println("Test 1: numbers.len() = {numbers.len()}")
    if (numbers.len() != 3):
        return Result.Ok(1)
    if (numbers.get(0)?? != 10 or numbers.get(1)?? != 20 or numbers.get(2)?? != 30):
        return Result.Ok(2)

    # Test 2: Direct initialization with empty array
    let string[] empty = create_empty()??
    println("Test 2: empty.len() = {empty.len()}")
    if (empty.len() != 0):
        return Result.Ok(3)

    # Test 3: Direct initialization with function parameter
    let u8[] sequence = create_sequence(5)??
    println("Test 3: sequence.len() = {sequence.len()}")
    if (sequence.len() != 5):
        return Result.Ok(4)

    # Test 4: Direct initialization from method call
    let string text = "Mostly Harmless"
    let u8[] bytes = text.to_bytes()
    println("Test 4: bytes.len() = {bytes.len()}")
    if (bytes.len() != 15):
        return Result.Ok(5)

    # Test 5: Verify RAII cleanup works correctly
    let i32[] temp1 = create_numbers()??
    temp1.destroy()
    let u8[] temp2 = create_sequence(3)??
    temp2.destroy()
    println("Test 5: RAII cleanup successful")

    println("All tests passed!")
    return Result.Ok(0)

fn main() i32:
    let i32 result = run_test().realise(99)
    return Result.Ok(result)
