# Test that constraints don't break type inference for generic structs

perk Hashable:
    fn hash() u64

struct Point:
    i32 x
    i32 y

extend Point with Hashable:
    fn hash() u64:
        let u64 hx = self.x as u64
        let u64 hy = self.y as u64
        return hx + hy

struct Container<T: Hashable>:
    T value

fn main() i32:
    # Type inference for generic constructors not implemented yet
    # Explicit type annotation required for now
    let Container<Point> c = Container(Point(10, 20))
    println(c.value.x)
    return Result.Ok(0)
