# Test that constraints propagate through nested generic types

perk Hashable:
    fn hash() u64

struct Point:
    i32 x
    i32 y

extend Point with Hashable:
    fn hash() u64:
        let u64 hx = self.x as u64
        let u64 hy = self.y as u64
        return hx + hy

struct Inner<U: Hashable>:
    U value

struct Outer<T: Hashable>:
    Inner<T> inner

fn main() i32:
    # Nested generics: both Outer and Inner require Hashable
    # Point implements Hashable, so this should work
    let Inner<Point> inner = Inner(Point(10, 20))
    let Outer<Point> outer = Outer(inner)
    println(outer.inner.value.x)
    return Result.Ok(0)
