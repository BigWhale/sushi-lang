# Test generic functions using generic enum types (Maybe<T>)
# This tests body substitution with generic enum instantiation and pattern matching

fn make_maybe_some<T>(T value) i32:
    # Create generic enum variant with generic type and verify it works
    let Maybe<T> m = Maybe.Some(value)
    match m:
        Maybe.Some(_) -> return Result.Ok(0)
        Maybe.None() -> return Result.Ok(1)

fn unwrap_or<T>(Maybe<T> maybe, T default_value) T:
    # Pattern match on generic enum
    match maybe:
        Maybe.Some(val) -> return Result.Ok(val)
        Maybe.None() -> return Result.Ok(default_value)

fn run_test() i32:
    # Test creating Maybe with i32
    let i32 status1 = make_maybe_some(42)??
    if (status1 != 0):
        return Result.Ok(10)

    # Test creating Maybe with string
    let i32 status2 = make_maybe_some("test")??
    if (status2 != 0):
        return Result.Ok(11)

    # Test pattern matching on Maybe<i32>
    let Maybe<i32> m1 = Maybe.Some(42)
    let i32 val1 = unwrap_or(m1, 0)??
    if (val1 != 42):
        return Result.Ok(1)

    # Test pattern matching on Maybe<string>
    let Maybe<string> m2 = Maybe.Some("test")
    let string val2 = unwrap_or(m2, "default")??
    if (val2 != "test"):
        return Result.Ok(2)

    # Test Maybe.None
    let Maybe<i32> m3 = Maybe.None()
    let i32 val3 = unwrap_or(m3, 99)??
    if (val3 != 99):
        return Result.Ok(3)

    return Result.Ok(0)

fn main() i32:
    let i32 result = run_test().realise(99)
    return Result.Ok(result)
