# TEST_TYPE: runtime
# EXPECTED_OUTPUT: Test 1: Pair<i32, string> - 42 and hello
# EXPECTED_OUTPUT: Test 2: Pair<f64, i32> - 3.14 and 100
# EXPECTED_OUTPUT: Test 3: Mixed with Result - 200 300

# Comprehensive test of user-defined generic enums

enum Pair<T, U>:
    Both(T, U)
    Left(T)
    Right(U)

fn create_int_string_pair(i32 x, string y) Pair<i32, string>:
    return Result.Ok(Pair.Both(x, y))

fn create_float_int_pair(f64 x, i32 y) Pair<f64, i32>:
    return Result.Ok(Pair.Both(x, y))

fn main() i32:
    # Test 1: Pair<i32, string>
    let Result<Pair<i32, string>, StdError> r1 = create_int_string_pair(42, "hello")
    let Pair<i32, string> p1 = r1.realise(Pair.Left(0))
    match p1:
        Pair.Both(a, b) ->
            println("Test 1: Pair<i32, string> - {a} and {b}")
        Pair.Left(a) ->
            println("Test 1: Left {a}")
        Pair.Right(b) ->
            println("Test 1: Right {b}")

    # Test 2: Pair<f64, i32>
    let Result<Pair<f64, i32>, StdError> r2 = create_float_int_pair(3.14, 100)
    let Pair<f64, i32> p2 = r2.realise(Pair.Left(0.0))
    match p2:
        Pair.Both(x, y) ->
            println("Test 2: Pair<f64, i32> - {x} and {y}")
        Pair.Left(x) ->
            println("Test 2: Left {x}")
        Pair.Right(y) ->
            println("Test 2: Right {y}")

    # Test 3: Mix user generic with built-in generic
    let Result<Pair<i32, i32>, StdError> p3 = Result.Ok(Pair.Both(200, 300))
    if (p3):
        let Pair<i32, i32> inner = p3.realise(Pair.Both(0, 0))
        match inner:
            Pair.Both(a, b) ->
                println("Test 3: Mixed with Result - {a} {b}")
            Pair.Left(a) ->
                println("Test 3: Left {a}")
            Pair.Right(b) ->
                println("Test 3: Right {b}")

    return Result.Ok(0)
