# Test same generic function instantiated with many different types
# This ensures monomorphization creates separate versions correctly

fn triple<T>(T value) T:
    # Just return the value (simplified version)
    return Result.Ok(value)

fn run_test() i32:
    # Instantiate with i32
    let i32 v1 = triple(42)??
    if (v1 != 42):
        return Result.Ok(1)

    # Instantiate with i64
    let i64 v2 = triple(100 as i64)??
    if (v2 != 100 as i64):
        return Result.Ok(2)

    # Instantiate with i8
    let i8 v3 = triple(10 as i8)??
    if (v3 != 10 as i8):
        return Result.Ok(3)

    # Instantiate with u32
    let u32 v4 = triple(200 as u32)??
    if (v4 != 200 as u32):
        return Result.Ok(4)

    # Instantiate with u64
    let u64 v5 = triple(300 as u64)??
    if (v5 != 300 as u64):
        return Result.Ok(5)

    # Instantiate with f64
    let f64 v6 = triple(3.14)??
    if (v6 < 3.13 or v6 > 3.15):
        return Result.Ok(6)

    # Instantiate with string
    if (triple("test")?? == ""):
        return Result.Ok(10)

    # Call again with already-instantiated types to verify they work
    let i32 v8 = triple(999)??
    if (v8 != 999):
        return Result.Ok(7)

    # Another string call
    if (triple("again")?? == ""):
        return Result.Ok(11)

    return Result.Ok(0)

fn main() i32:
    let i32 result = run_test().realise(99)
    return Result.Ok(result)
