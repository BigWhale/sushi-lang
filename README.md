# Sushi Lang

<!-- For sushi-lang (public) repo, use: 5bfbd5156dec23acfe18dd7956e251ba -->
<!-- For sushi (dev) repo, use: e893b92ba7b7561fae565f832f83159d -->
[![Tests](https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/BigWhale/5bfbd5156dec23acfe18dd7956e251ba/raw/badge_status.json)](https://github.com/BigWhale/sushi-lang/actions/workflows/test.yml)
[![Total Tests](https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/BigWhale/5bfbd5156dec23acfe18dd7956e251ba/raw/badge_total.json)](https://github.com/BigWhale/sushi-lang/actions/workflows/test.yml)
[![Passed](https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/BigWhale/5bfbd5156dec23acfe18dd7956e251ba/raw/badge_passed.json)](https://github.com/BigWhale/sushi-lang/actions/workflows/test.yml)
[![Failed](https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/BigWhale/5bfbd5156dec23acfe18dd7956e251ba/raw/badge_failed.json)](https://github.com/BigWhale/sushi-lang/actions/workflows/test.yml)

A compiled programming language with a Lark parser frontend and
LLVM backend that produces native binaries.

**PARENTAL ADVISORY**

This project is a result of a thought process when I asked myself
"how hard is it to create a programming language?"
Then I went and wrote:

```
fn main():
    return(0)
```
I spent a couple of hours reading about grammar parsers, AST, LLVM,
and similar stuff, and then after some time I had a compiled
executable file that did nothing.

Then I started working on `print()` and then on variables, soon
after this I realized that this is going way too slow and I will
need to ask ~~people~~robots to help me. Then things really took
off.

Long story short, now I am vibe coding a programming language,
losing my mind trying to convince LLMs to output the code that I
want, and I generally know much more about compilers that I used to
know. It's been fun.

If you are triggered by mediocre and badly written code, you might
want to stay away. Or you might find this funny.

Apart from this section, most of the things in the documentation
were just briefly checked for sanity, and revised by a human. Same
goes for code. A rough estimate is that 80% of the code was
iteratively generated by LLMs. Then LLMs were used to refactor this
code. Obvious mistakes spotted by a human were then corrected mostly
by LLMs. This code base is in some parts quite ridiculous and can
bring even seasoned developers and code reviewers to tears. You have
been warned.

Sushi is actively tested on macOS (Apple Silicon) and Linux (via
CI). No testing has been done on Windows yet, so the current status
is unknown.

What is the goal with Sushi? Mostly me teaching myself about
compilers and related subjects, and playing around with LLMs. At one
point I will decide that I added enough features, then I will try
and turn it into a self-hosted compiler.



## Overview

Sushi Lang is a statically-typed compiled language designed with
safety, simplicity, and performance in mind. The compiler follows a
clean multi-pass architecture with comprehensive semantic analysis
and LLVM-powered code generation.

**Key Features:**
- Static type system with explicit casting
- Generic types with compile-time monomorphization (`Result<T>`,
  `Maybe<T>`, user-defined structs, enums, and functions)
- Generic functions with automatic type inference and perk constraints
- Perks (traits/interfaces) for polymorphic behavior with static dispatch
- Error propagation operator (`??`) for ergonomic error handling
- Mutable references with compile-time borrow checking
- Extension methods for zero-cost method chaining
- Rust-style enums with exhaustive pattern matching
- Automatic memory management (RAII) for structs and arrays
- Full UTF-8 Unicode support
- Native code generation via LLVM

## Quick Start

```bash
# Compile a program
./sushic hello.sushi

# Run the compiled binary
./hello

# Optimization levels
./sushic --opt O2 program.sushi       # Recommended: balanced performance
./sushic --opt O3 program.sushi       # Maximum performance
```

### Hello World

```sushi
fn main() i32:
    println("Mostly Harmless")
    return Result.Ok(0)
```

## Documentation

ðŸ“š **[Complete Documentation](docs/)**

### Getting Started
- [Installation and Setup](docs/getting-started.md) - Get Sushi
  running on your machine
- [Language Guide](docs/language-guide.md) - Friendly tour of
  Sushi's features
- [Examples](docs/examples/) - Learn by example (21 hands-on
  programs)

### Language Reference
- [Language Reference](docs/language-reference.md) - Complete syntax
  and semantics
- [Standard Library](docs/standard-library.md) - Built-in types and
  functions
- [Error Handling](docs/error-handling.md) - `Result<T>`,
  `Maybe<T>`, and `??` operator
- [Memory Management](docs/memory-management.md) - RAII, references,
  and ownership
- [Generics](docs/generics.md) - Generic types and compile-time
  monomorphization
- [Perks](docs/perks.md) - Traits/interfaces for polymorphic behavior

### Compiler
- [Compiler Reference](docs/compiler-reference.md) - CLI options and
  optimization levels
- [Architecture](docs/internals/architecture.md) - Compiler design
  and structure
- [Semantic Passes](docs/internals/semantic-passes.md) - Pass-by-
  pass analysis
- [Backend](docs/internals/backend.md) - LLVM code generation

## Language Highlights

### Explicit Error Handling

All functions return `Result<T>` for type-safe error handling:

```sushi
fn divide(i32 a, i32 b) i32:
    if (b == 0):
        return Result.Err()
    return Result.Ok(a / b)

fn main() i32:
    let i32 result = divide(10, 2).realise(0)
    println("Result: {result}")
    return Result.Ok(0)
```

### Error Propagation

The `??` operator unwraps values or propagates errors automatically:

```sushi
fn read_config() string:
    let file f = open("config.txt", FileMode.Read())??
    let string content = f.read()
    f.close()
    return Result.Ok(content)
```

### Pattern Matching

Exhaustive pattern matching with enums:

```sushi
enum Status:
    Idle()
    Working(i32 progress)
    Done()

fn check(Status s) ~:
    match s:
        Status.Idle() -> println("Idle")
        Status.Working(progress) -> println("Progress: {progress}%")
        Status.Done() -> println("Completed")
    return Result.Ok(~)
```

### Generic Types

Type-safe generics with zero runtime overhead:

```sushi
struct Pair<T, U>:
    T first
    U second

fn main() i32:
    let Pair<i32, string> p = Pair(first: 42, second: "answer")
    println("{p.second}: {p.first}")
    return Result.Ok(0)
```

### Memory Safety

Compile-time borrow checking and RAII:

```sushi
fn increment(&i32 counter) ~:
    counter := counter + 1
    return Result.Ok(~)

fn main() i32:
    let i32 count = 0
    increment(&count)
    println("Count: {count}")  # 1
    return Result.Ok(0)
```

### Perks (Traits/Interfaces)

Static polymorphism through perks with zero runtime overhead:

```sushi
perk Hashable:
    fn hash() u64

struct Point:
    i32 x
    i32 y

extend Point with Hashable:
    fn hash() u64:
        return self.x as u64 + self.y as u64

# Generic function with perk constraint
fn compute_hash<T: Hashable>(T value) u64:
    return Result.Ok(value.hash())

fn main() i32:
    let Point p = Point(10, 20)
    let u64 h = compute_hash(p)??  # Type inferred automatically
    println("Hash: {h}")
    return Result.Ok(0)
```

## Optimization Levels

| Level         | Description              | Use Case                       |
|---------------|--------------------------|--------------------------------|
| `none` / `O0` | No optimization          | Debugging                      |
| `mem2reg`     | Basic SROA (default)     | Quick builds                   |
| `O1`          | Basic optimizations      | Fast compilation               |
| `O2`          | Moderate optimizations   | **Recommended** for production |
| `O3`          | Aggressive optimizations | Maximum performance            |

```bash
# Development
./sushic program.sushi

# Production
./sushic --opt O2 program.sushi -o app
```

## Testing

```bash
# Run test suite
python tests/run_tests.py

# Run with runtime validation
python tests/run_tests.py --enhanced

# Filter specific tests
python tests/run_tests.py --filter hashmap
```

## Examples

Check out the [examples directory](docs/examples/) for hands-on
learning:

- [01-hello.sushi](docs/examples/01-hello.sushi) - Basic program
  structure
- [04-strings.sushi](docs/examples/04-strings.sushi) - String
  operations
- [07-result.sushi](docs/examples/07-result.sushi) - Error handling
- [15-lists.sushi](docs/examples/15-lists.sushi) - Generic lists
- [16-hashmaps.sushi](docs/examples/16-hashmaps.sushi) - Hash tables

[See all 22 examples â†’](docs/examples/)

## Project Structure

```
sushi/
â”œâ”€â”€ compiler.py              # Main compiler entry point
â”œâ”€â”€ grammar.lark             # Lark grammar specification
â”œâ”€â”€ semantics/               # Semantic analysis passes
â”‚   â”œâ”€â”€ passes/              # Multi-pass type checking
â”‚   â””â”€â”€ generics/            # Generic type system
â”œâ”€â”€ backend/                 # LLVM code generation
â”‚   â”œâ”€â”€ expressions/         # Expression emission
â”‚   â”œâ”€â”€ statements/          # Statement emission
â”‚   â””â”€â”€ types/               # Type-specific codegen
â”œâ”€â”€ stdlib/                  # Standard library
â”‚   â”œâ”€â”€ src/                 # Python IR generators
â”‚   â””â”€â”€ dist/                # Precompiled .bc files
â”œâ”€â”€ tests/                   # Test suite
â””â”€â”€ docs/                    # Documentation
```

## Philosophy

Sushi combines:
- **Rust's safety** - Ownership, borrowing, explicit error handling
- **Python's simplicity** - Clean syntax, readable code
- **C's performance** - Zero-cost abstractions, native binaries

## Development Setup

### Prerequisites

- **Python 3.13+** (managed by uv)
- **LLVM 20** (llvmlite 0.45 requirement)
- **cmake** (required for building llvmlite)

### Installation

```bash
# Install uv (if not already installed)
curl -LsSf https://astral.sh/uv/install.sh | sh

# Install cmake (macOS)
brew install cmake

# Install LLVM 20
brew install llvm@20

# Install Python dependencies
uv sync --dev

# Build standard library
uv run python stdlib/build.py

# Test installation
./sushic --help
```

**Important**: LLVM 20 is keg-only on macOS. The build process will automatically use the correct version through the `LLVM_CONFIG` environment variable if needed.

### Development Commands

```bash
# Compile with debug output
./sushic --traceback --dump-ll program.sushi

# View AST
./sushic --dump-ast program.sushi

# Save LLVM IR
./sushic --write-ll program.sushi
cat program.ll

# Run test suite
uv run python tests/run_tests.py

# Run with runtime validation
uv run python tests/run_tests.py --enhanced
```

## Contributing

Contributions welcome! See documentation for compiler internals and
architecture.

---

**[ðŸ“š Read the full documentation](docs/)** | **[ðŸš€ Get started](docs/getting-started.md)** | **[ðŸ’¡ See examples](docs/examples/)**
