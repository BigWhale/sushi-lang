# Example 24: Perks with Generic Constraints
#
# This example demonstrates:
# - Generic functions with perk constraints
# - Automatic type inference
# - Multiple types implementing the same perk

# Define a perk
perk Describable:
    fn describe() string

# Define custom types
struct Robot:
    string name
    i32 battery

struct Ship:
    string name
    i32 crew

# Implement Describable for Robot
extend Robot with Describable:
    fn describe() string:
        return "Robot: {self.name} (battery: {self.battery}%)"

# Implement Describable for Ship
extend Ship with Describable:
    fn describe() string:
        return "Ship: {self.name} (crew: {self.crew})"

# Generic function with perk constraint
fn print_description<T: Describable>(T item) ~:
    println(item.describe())
    return Result.Ok(~)

# Another generic function
fn get_description<T: Describable>(T item) string:
    return Result.Ok(item.describe())

fn main() i32:
    println("=== Generic Constraints Example ===")
    println("")

    # Create instances
    let Robot marvin = Robot("Marvin", 42)
    let Ship hog = Ship("Heart of Gold", 5)

    # Generic function with type inference
    println("1. Using generic function with Robot:")
    print_description(marvin)

    println("")
    println("2. Using generic function with Ship:")
    print_description(hog)

    println("")
    println("3. Getting description as string:")
    let string desc1 = get_description(marvin).realise("")
    let string desc2 = get_description(hog).realise("")
    println("Desc 1: {desc1}")
    println("Desc 2: {desc2}")

    return Result.Ok(0)
