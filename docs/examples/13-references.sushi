# Example 13: References and Borrowing
#
# This example demonstrates Sushi's borrowing system. Borrowing allows a function
# to temporarily access a variable without taking ownership of it. In Sushi,
# borrowing is implemented through references - when you pass a variable by
# reference (using the & prefix), you are "borrowing" that variable.
#
# Key concepts covered:
# - Borrowing: Temporary access to a variable without ownership transfer
# - Mutable references (&T): The mechanism for borrowing in Sushi
# - Reference parameters allow in-place modification
# - No ownership transfer - original variable remains valid after call
# - Compile-time borrow checking (one active borrow per variable)
# - Unit return type (~) for side-effect-only functions
#
# Note: Unlike dynamic arrays which use move semantics, primitives and strings
# use copy semantics. Borrowing via references avoids copies and enables mutation.

fn increment_count(&i32 counter) ~:
    # Modify the referenced variable in-place
    # The caller's variable is directly updated
    counter := counter + 1
    return Result.Ok(~)

fn double_value(&i32 value) ~:
    # Another example of in-place modification via reference
    value := value * 2
    return Result.Ok(~)

fn main() i32:
    let i32 towels = 0

    # Borrow towels using & prefix - this passes a reference to the function
    # The function can modify towels, but we retain ownership
    increment_count(&towels)
    increment_count(&towels)
    increment_count(&towels)

    println("Towels collected: {towels}")  # Prints: 3

    let i32 answer = 21

    # Borrow answer - the function modifies it in-place via the reference
    double_value(&answer)

    println("Doubled answer: {answer}")  # Prints: 42

    # Original variables are still valid after being borrowed
    # Borrowing doesn't consume or move the value
    println("Still can use towels: {towels}")
    println("Still can use answer: {answer}")

    return Result.Ok(0)

